

\section{Quick Theory}
\subsection{Digital Circuits}
Talking of circuits, we differ between analogue circuits and digital circuits. The difference lays actually in the format of the signal that represents the carried information. \newline
An analogue signal uses some attribute of the medium to convey the signal's information. In electric circuits is it the voltage, current or frequency, that is varied in order to create an electric signal. Analog electronic circuits are those in which the threshold of the current or voltage varies \underline{continuously} over time, corresponding to the information being represented. They follow Kirchhoff's circuit laws: all the currents at a node (a place where wires meet), and the voltage around a closed loop of wires is zero. \newline
In digital electronic circuits, electric signals take on \underline{discrete values} to represent logical and numeric values, which then represent the information that is being processed. Every digital circuit is also a analog circuit, but it has ideally (just two) discrete potential levels in use. 

\subsection{Binary Numbers}
%erkläre mehr, über Dezimalzahlsystem, Vergleich Dezimal/Binär, Übertrag, etc.!!! Motivation, wir haben nur zwei Zustände. 
Almost always, binary encoding is used: one voltage represents a binary '1' and another voltage, usually a value near the ground potential, represents a binary '0'. Those binary digits, each of them called one 'bit', can then be used to represent numbers and characters and therefore to carry information. The binary code was invented and first used by Gottfried Leibniz in 1679.

\begin{figure}[H]
\centering
\begin{minipage}{0.5\textwidth}
%  \centering
  \includegraphics[width=1\textwidth]{binary.png}%
  \caption{Binary representation of one bit}%
  \label{fig:binary}
\end{minipage}%
\begin{minipage}{.4\textwidth}
  \centering
  \includegraphics[width=0.8\textwidth]{leibniz}%
  \caption{Painting of Gottfried Leibniz}%
  \label{fig:leibniz}
\end{minipage}
\end{figure}

\subsection{Boolean Algebra and its implementation}
To understand how a processor can actually perform calculations and follow algorithms with those binary numbers, some knowledge about Boolean logic has to be obtained first. The Boolean Algebra (first half of the 19. century by George Boole) defines three main operations: 

%\noindent
\begin{itemize}
 \item \textbf{The conjunction:} $a\land b$ is $1$ if and only if $a$ is $1$ and $b$ is $1$.\\
 \item \textbf{The disjunction:} $a\lor b$  is $1$ if and only if $a$ is $1$ or $b$ is $1$ or $a\wedge b$ is $1$.\\
 \item \textbf{The negation:}  $\neg a$ is $1$ if and only if $a$ is $0$. A negated variable $a$ is also often written as $\overline{a}$.
\end{itemize}

\noindent
The operations of the Boolean Algebra are Associative, Commutative and Distributive. They have a Neutral, an Inverse and a Zero element. One can easily imagine, that those operations can be combined and added in number to create more complex calculation operators. This is actually exactly what happens in our computers, servers and smartphones, of course on a very large scale. 
\subsection{Truth tables}
These Boolean operators can be represented in so called truth tables as follows:

%%include also ==, XOR, etc... 

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c}
\textbf{$a$} & \textbf{$b$} & \textbf{$a\land b$} & \textbf{$a\lor b$} & \textbf{$\neg a$} \\ \hline
0          & 0          & 0            & 0            & 1           \\
1          & 0          & 0            & 1            & 0           \\
0          & 1          & 0            & 1            & 1           \\
1          & 1          & 1            & 1            & 0          
\end{tabular}
\caption{truth table}
\label{tab:truth}
\end{table}

One can also represent more operations than the three basic one. Let's look for example at the comparison operator, the exclusive or and the negated and. 


\subsection{Logical Formula in Disjunctive normal-form}
To construct a function, one wants to convert the information in the truth table in one compact formula. We use the disjuctive normal-form, which works as follows: 
\newline \textbf{In the column of the operator output, look for logical $1$. Now for each line that has a $1$ in the output field, combine the input variables with a logical \textit{and} ($\land$). If the variable has a entry of $0$, we use the inversion notation with an overline. Then connect those expressions with a logical \textit{or} ($\lor$).} 
\newline Now we have the boolean function in \underline{disjunctive normal-form} that describes our operator. Let's make two examples: \newline
\begin{enumerate}
 \item [\textbf{AND:}]$(a\land b)$
 \item [\textbf{OR:}]$(a\land \overline{b})\lor(\overline{a}\land b)\lor(a\land b)$
\end{enumerate}

As you can see, does the expression for the \textbf{OR} look unnecessarily complicated, we could just write $(a\lor b)$. This would be in conjunctive normal-form, but the point is, to use always the same logical system (disjunctive normal-form!). When we have described the operator in this form, we can built it up easily with basic circuits elements.  

\subsection{Drawing of a circuit}
After having a function that describes our operator in disjunctive normal-form, is it very easy to translate this into a circuit. We just replace the symbols in the fomula with the circuit symbols that are shown here. For larger circuits do we then connect all the inputs and outputs according to the structure (parenthesis!) of the formula.

\begin{figure}[H]
\centering
  \includegraphics[height=0.8\textwidth]{logic_symbols}%
  \caption{Logic circuit symbols}%
  \label{fig:logic_symbols}
\end{figure}
Once drawn, such a circuit can look like this:

\begin{figure}[H]
\centering
  \includegraphics[height=0.3\textwidth]{equivalence}%
  \caption{Example for circuit design: the equivalence}%
  \label{fig:equivalence}
\end{figure}

\noindent
Now, before we set up this circuit, we have to think practical: Would it not be much more beautiful, and also much more easy, to just have one element instead of three different ones? In electronics, especially today in microelectronics (computers!), it is a key factor to build a circuit as easy as possible. Now, one can prove mathematically, that every circuit that is build up by OR's, AND's and Inversions, can also be build up by NAND's (negated AND) as well as by NOR's (negated OR). The circuit is shown again, but this time the elements were replaced by NAND's. 

\begin{figure}[H]
\centering
  \includegraphics[height=0.2\textwidth]{equivalence_optimized}%
  \caption{Optimized equivalence circuit}%
  \label{fig:equivalence_optimized}
\end{figure}

\section{Combinatoric circuits}
\subsection{General}
We differ between combinatoric circuits and sequential circuits. Combinatoric circuits are logical functions, whose \underline{output states are always exactly defined through their input variables}. This point will become more clear later when we look at sequential circuits. 

\subsection{Construction of a combinatoric circuit}
\begin{enumerate}
	\item Write down the truth table.
	\item\label{it:1} Construct the disjunctive normal form from your truth table.
	\item Draw the circuit according to step \ref{it:1}.
	\item Transform the circuit in such a way that it only uses NAND Gates.
	\item Build the XOR you have drawn with the giant NAND gates.
	\item How many NAND gates do you need? See if you can loose one or two gates.
\end{enumerate}



%\subsubsection{Truth table}                            
%\subsubsection{Equation}                               
%\subsubsection{Draw circuit with logic elements}       
%\subsubsection{Unify}                                  
                                                       
\section{Sequential circuit}                           
\subsection{General}
Now we look at sequential circuits, which is different from the combinatoric circuit. Sequential circuits have something that can be looked at as a memory. The clue is, that the output of an operator is used again as one of the inputs. This means, that the circuit depends not only on combinatoric input variables, but also from the output of the step before. In this way, the functionality of a memory is realized. 

\subsection{Elements}
\subsubsection{Latch}
This concept is easily explained with the most basic realization of a sequential circuit: The latch. 

***picture latch***


\subsubsection{Clock}
\subsection{Construction of a sequential circuit}
